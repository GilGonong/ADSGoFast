using System;
using System.IO;
using System.Threading.Tasks;
using FunctionApp.DataAccess;
using FunctionApp.Models;
using FunctionApp.Models.Options;
using FunctionApp.Services;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Extensions.Http;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace FunctionApp.Functions
{
    /// <summary>
    /// Stores logs generated by the data factory (or other callers) into the default logging implemented by the
    ///  Azure Function (App Insights)
    /// </summary>
    public class AdfLogging
    {
        private readonly IOptions<ApplicationOptions> _options;
        private readonly TaskMetaDataDatabase _taskMetaDataDatabase;

        public AdfLogging(IOptions<ApplicationOptions> options, TaskMetaDataDatabase taskMetaDataDatabase)
        {
            _options = options;
            _taskMetaDataDatabase = taskMetaDataDatabase;
        }
        [FunctionName("Log")]
        public async Task<IActionResult> Run(
            [HttpTrigger(AuthorizationLevel.Function, "post", Route = null)] HttpRequest req,
            ILogger log, ExecutionContext context)
        {
            Guid executionId = context.InvocationId;
            FrameworkRunner frp = new FrameworkRunner(log, executionId);

            FrameworkRunnerWorkerWithHttpRequest worker = LogCore;
            FrameworkRunnerResult result = await frp.Invoke(req, "Log", worker);
            if (result.Succeeded)
            {
                return new OkObjectResult(JObject.Parse(result.ReturnObject));
            }
            else
            {
                return new BadRequestObjectResult(new { Error = "Execution Failed...." });
            }

        }
        public async Task<JObject> LogCore(HttpRequest req,
            Logging.Logging LogHelper)
        {
            //short frameworkNumberOfRetries = _options.Value.FrameworkNumberOfRetries;
            short frameworkNumberOfRetries = 1;

            string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
            dynamic data = JsonConvert.DeserializeObject(requestBody);

            dynamic taskInstanceId = data["TaskInstanceId"];
            dynamic numberOfRetries = data["NumberOfRetries"];
            dynamic postObjectExecutionUid = data["ExecutionUid"];
            dynamic adfRunUid = data["RunId"];
            dynamic logTypeId = data["LogTypeId"];//1 Error, 2 Warning, 3 Info, 4 Performance, 5 Debug
            dynamic logSource = data["LogSource"];//ADF, AF
            dynamic activityType = data["ActivityType"];
            dynamic startDateTimeOffSet = data["StartDateTimeOffSet"];
            dynamic status = data["Status"]; //Started Failed Completed
            dynamic comment = data["Comment"];
            comment = comment == null ? "" : comment.ToString();
            comment = System.Web.HttpUtility.UrlDecode(comment);
            dynamic endDateTimeOffSet = data["EndDateTimeOffSet"];
            dynamic rowsInserted = data["RowsInserted"];

            if (taskInstanceId != null) { LogHelper.DefaultActivityLogItem.TaskInstanceId = (long?)taskInstanceId; }
            if (logSource != null) { LogHelper.DefaultActivityLogItem.LogSource = (string)logSource; }
            if (logTypeId != null) { LogHelper.DefaultActivityLogItem.LogTypeId = (short?)logTypeId; }
            if (startDateTimeOffSet != null) { LogHelper.DefaultActivityLogItem.StartDateTimeOffset = (DateTimeOffset)startDateTimeOffSet; }
            if (status!= null) { LogHelper.DefaultActivityLogItem.Status = (string)status; }
            if (endDateTimeOffSet != null) { LogHelper.DefaultActivityLogItem.EndDateTimeOffset = (DateTimeOffset)endDateTimeOffSet; }
            if (postObjectExecutionUid != null) { LogHelper.DefaultActivityLogItem.ExecutionUid = (Guid?)postObjectExecutionUid; }

            LogHelper.LogInformation(comment);

            if (activityType == "Data-Movement-Master")
            {
                TaskInstance.TaskStatus taskStatus;
                if (status == "Failed")
                {
                    //Todo Put Max Number of retries in DB at TaskMasterLevel -- This has now been done. Have left logic in function as stored procedure handles with all failed statuses. 
                    numberOfRetries = (numberOfRetries == null) ? 0 : (int)numberOfRetries + 1;
                    taskStatus = ((numberOfRetries < frameworkNumberOfRetries) ? TaskInstance.TaskStatus.FailedRetry : TaskInstance.TaskStatus.FailedNoRetry);

                }
                else
                {
                    if (Enum.TryParse<TaskInstance.TaskStatus>(status.ToString(), out taskStatus) == false)
                    {
                        string invalidStatus = $"TaskStatus Enum does not exist for: {status}";
                        LogHelper.LogErrors(new Exception(invalidStatus));
                        comment = string.Concat(comment,".",invalidStatus);
                        taskStatus = TaskInstance.TaskStatus.FailedNoRetry;
                    }
                }
                await _taskMetaDataDatabase.LogTaskInstanceCompletion((Int64)taskInstanceId, (Guid)postObjectExecutionUid, taskStatus, (Guid)adfRunUid, (String)comment);
            }

            return new JObject
            {
                ["Result"] = "Complete"
            };
        }
    }
}